/*
Copyright (C) 2025  Mark CLI Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

package main

import (
	"bufio"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

// RC file paths for unified shell configuration
const (
	bashRCFile = ".mark_bash_rc"
	zshRCFile  = ".mark_zsh_rc"
	fishRCFile = ".config/fish/conf.d/mark.fish"
)

// Source line markers for shell configs
const (
	sourceLineMarker = "# mark shell integration"
)

// getMarkPath returns the path to the mark binary
func getMarkPath() string {
	markPath, err := os.Executable()
	if err != nil {
		markPath, err = exec.LookPath("mark")
		if err != nil {
			return "mark"
		}
	}
	return markPath
}

// generateBashRC generates unified bash RC content with aliases and/or completions
func generateBashRC(markPath string, includeAliases, includeCompletions bool) string {
	var features []string
	if includeAliases {
		features = append(features, "aliases")
	}
	if includeCompletions {
		features = append(features, "completions")
	}

	var sb strings.Builder
	sb.WriteString("#!/bin/bash\n")
	sb.WriteString("# mark shell configuration\n")
	sb.WriteString("# Generated by mark - do not edit manually\n")
	sb.WriteString(fmt.Sprintf("# Features: %s\n", strings.Join(features, " ")))
	sb.WriteString("\n")

	if includeAliases {
		sb.WriteString("# === ALIASES ===\n")
		sb.WriteString(fmt.Sprintf("alias marks='%s -l'\n", markPath))
		sb.WriteString(fmt.Sprintf("alias unmark='%s -d'\n", markPath))
		sb.WriteString(fmt.Sprintf(`function jump() {
    local target=$(%s -j "$@")
    if [ $? -eq 0 ] && [ -n "$target" ]; then
        cd "$target"
    fi
}
`, markPath))
		sb.WriteString("\n")
	}

	if includeCompletions {
		sb.WriteString("# === COMPLETIONS ===\n")
		sb.WriteString(`# Helper function to get bookmarks with their paths for display
_mark_list_with_paths() {
    mark -l 2>/dev/null || true
}

_mark_complete() {
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"
    local cmd="${COMP_WORDS[0]}"

    # If we're on the first argument
    if [[ ${COMP_CWORD} -eq 1 ]]; then
        # If user starts typing a dash, offer flags (only for 'mark' command)
        if [[ "$cur" == -* && "$cmd" == "mark" ]]; then
            local flags="-l -d -j -v -h --config --configure --autocomplete --alias --help --version"
            COMPREPLY=($(compgen -W "$flags" -- "${cur}"))
        else
            # For bookmark completion, show formatted list
            if [[ -d ~/.marks ]]; then
                # Get bookmark names for actual completion
                local marks=$(ls ~/.marks 2>/dev/null | tr '\n' ' ')
                COMPREPLY=($(compgen -W "$marks" -- "${cur}"))

                # Only show formatted list on double-tab (COMP_TYPE = 63)
                if [[ ${#COMPREPLY[@]} -gt 1 ]] && [[ ${COMP_TYPE:-} -eq 63 ]]; then
                    echo >&2  # Newline before the list
                    _mark_list_with_paths >&2
                fi
            fi
        fi
    # If previous was -d or -j, offer bookmark names with paths
    elif [[ "$prev" == "-d" || "$prev" == "-j" ]]; then
        if [[ -d ~/.marks ]]; then
            local marks=$(ls ~/.marks 2>/dev/null | tr '\n' ' ')
            COMPREPLY=($(compgen -W "$marks" -- "${cur}"))

            # Only show formatted list on double-tab (COMP_TYPE = 63)
            if [[ ${#COMPREPLY[@]} -gt 1 ]] && [[ ${COMP_TYPE:-} -eq 63 ]]; then
                echo >&2  # Newline before the list
                _mark_list_with_paths >&2
            fi
        fi
    fi
}

complete -F _mark_complete mark
complete -F _mark_complete marks
complete -F _mark_complete unmark
complete -F _mark_complete jump
`)
	}

	return sb.String()
}

// generateZshRC generates unified zsh RC content with aliases and/or completions
func generateZshRC(markPath string, includeAliases, includeCompletions bool) string {
	var features []string
	if includeAliases {
		features = append(features, "aliases")
	}
	if includeCompletions {
		features = append(features, "completions")
	}

	var sb strings.Builder
	sb.WriteString("#!/bin/zsh\n")
	sb.WriteString("# mark shell configuration\n")
	sb.WriteString("# Generated by mark - do not edit manually\n")
	sb.WriteString(fmt.Sprintf("# Features: %s\n", strings.Join(features, " ")))
	sb.WriteString("\n")

	if includeAliases {
		sb.WriteString("# === ALIASES ===\n")
		sb.WriteString(fmt.Sprintf("alias marks='%s -l'\n", markPath))
		sb.WriteString(fmt.Sprintf("alias unmark='%s -d'\n", markPath))
		sb.WriteString(fmt.Sprintf(`function jump() {
    local target=$(%s -j "$@")
    if [ $? -eq 0 ] && [ -n "$target" ]; then
        cd "$target"
    fi
}
`, markPath))
		sb.WriteString("\n")
	}

	if includeCompletions {
		sb.WriteString("# === COMPLETIONS ===\n")
		sb.WriteString("autoload -U +X compinit && compinit\n\n")
		sb.WriteString(`_mark_complete() {
    local cur="${words[CURRENT]}"
    local prev="${words[CURRENT-1]}"
    local cmd="${words[1]}"

    # If we're on the first argument
    if [[ $CURRENT -eq 2 ]]; then
        # If user starts typing a dash, offer flags (only for 'mark' command)
        if [[ "$cur" == -* && "$cmd" == "mark" ]]; then
            local flags=("-l" "-d" "-j" "-v" "-h" "--config" "--configure" "--autocomplete" "--alias" "--help" "--version")
            compadd -a flags
        else
            # For bookmark completion, parse 'mark -l' output to get names and descriptions
            if [[ -d ~/.marks ]]; then
                local -a marks descriptions
                local name desc

                # Parse mark -l output: "  name -> target" or "  name -> [broken] target"
                while IFS= read -r line; do
                    # Extract bookmark name (everything before ' ->')
                    name=$(echo "$line" | sed -E 's/^[[:space:]]*([^[:space:]]+)[[:space:]]*->.*/\1/')
                    # Extract description (everything from ' ->' onwards)
                    desc=$(echo "$line" | sed -E 's/^[[:space:]]*[^[:space:]]+[[:space:]]*(->.*)/\1/')

                    if [[ -n "$name" && -n "$desc" ]]; then
                        marks+=("$name")
                        descriptions+=("$desc")
                    fi
                done < <(mark -l 2>/dev/null)

                # Use compadd with descriptions
                if [[ ${#marks[@]} -gt 0 ]]; then
                    compadd -d descriptions -a marks
                fi
            fi
        fi

    # If previous was -d or -j, offer bookmark names with descriptions
    elif [[ "$prev" == "-d" || "$prev" == "-j" ]]; then
        if [[ -d ~/.marks ]]; then
            local -a marks descriptions
            local name desc

            # Parse mark -l output
            while IFS= read -r line; do
                name=$(echo "$line" | sed -E 's/^[[:space:]]*([^[:space:]]+)[[:space:]]*->.*/\1/')
                desc=$(echo "$line" | sed -E 's/^[[:space:]]*[^[:space:]]+[[:space:]]*(->.*)/\1/')

                if [[ -n "$name" && -n "$desc" ]]; then
                    marks+=("$name")
                    descriptions+=("$desc")
                fi
            done < <(mark -l 2>/dev/null)

            # Use compadd with descriptions
            if [[ ${#marks[@]} -gt 0 ]]; then
                compadd -d descriptions -a marks
            fi
        fi
    fi
}

compdef _mark_complete mark
compdef _mark_complete marks
compdef _mark_complete unmark
compdef _mark_complete jump
`)
	}

	return sb.String()
}

// generateFishRC generates unified fish RC content with aliases and/or completions
func generateFishRC(markPath string, includeAliases, includeCompletions bool) string {
	var features []string
	if includeAliases {
		features = append(features, "aliases")
	}
	if includeCompletions {
		features = append(features, "completions")
	}

	var sb strings.Builder
	sb.WriteString("# mark shell configuration\n")
	sb.WriteString("# Generated by mark - do not edit manually\n")
	sb.WriteString(fmt.Sprintf("# Features: %s\n", strings.Join(features, " ")))
	sb.WriteString("\n")

	if includeAliases {
		sb.WriteString("# === ALIASES ===\n")
		sb.WriteString(fmt.Sprintf("alias marks '%s -l'\n", markPath))
		sb.WriteString(fmt.Sprintf("alias unmark '%s -d'\n", markPath))
		sb.WriteString(fmt.Sprintf(`function jump
    set -l target (%s -j $argv)
    if test $status -eq 0 -a -n "$target"
        cd "$target"
    end
end
`, markPath))
		sb.WriteString("\n")
	}

	if includeCompletions {
		sb.WriteString("# === COMPLETIONS ===\n")
		sb.WriteString(`# Helper function to list bookmarks with their paths
function __fish_mark_list_bookmarks
    mark -l 2>/dev/null | while read -l line
        # Parse "  name -> target" format into "name\t-> target" format
        echo "$line" | sed -E 's/^[[:space:]]*([^[:space:]]+)[[:space:]]*(->.*)/\1\t\2/'
    end
end

complete -c mark -f
complete -c mark -s l -d "List bookmarks"
complete -c mark -s d -d "Delete bookmark" -r
complete -c mark -s j -d "Jump to bookmark" -r
complete -c mark -l config -d "Run setup/reconfigure"
complete -c mark -l configure -d "Run setup/reconfigure"
complete -c mark -l autocomplete -d "Setup/update command line autocompletion"
complete -c mark -l alias -d "Setup shell aliases"
complete -c mark -s v -l version -d "Show version"
complete -c mark -s h -l help -d "Show help"

# Complete with existing bookmark names with paths for main argument
complete -c mark -n '__fish_is_first_token' -a '(__fish_mark_list_bookmarks)'

# Complete with bookmark names and paths for -d and -j flags
complete -c mark -n '__fish_seen_subcommand_from -d' -a '(__fish_mark_list_bookmarks)'
complete -c mark -n '__fish_seen_subcommand_from -j' -a '(__fish_mark_list_bookmarks)'

# Alias completions with descriptions
complete -c marks -f -a '(__fish_mark_list_bookmarks)'
complete -c unmark -f -a '(__fish_mark_list_bookmarks)'
complete -c jump -f -a '(__fish_mark_list_bookmarks)'
`)
	}

	return sb.String()
}

// writeShellRC writes the unified RC file for the specified shell
func writeShellRC(shell string, includeAliases, includeCompletions bool) error {
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return fmt.Errorf("error getting home directory: %w", err)
	}

	markPath := getMarkPath()
	var content string
	var rcPath string

	switch shell {
	case "bash":
		content = generateBashRC(markPath, includeAliases, includeCompletions)
		rcPath = filepath.Join(homeDir, bashRCFile)
	case "zsh":
		content = generateZshRC(markPath, includeAliases, includeCompletions)
		rcPath = filepath.Join(homeDir, zshRCFile)
	case "fish":
		content = generateFishRC(markPath, includeAliases, includeCompletions)
		rcPath = filepath.Join(homeDir, fishRCFile)
		// Create conf.d directory if needed
		if err := os.MkdirAll(filepath.Dir(rcPath), 0755); err != nil {
			return fmt.Errorf("error creating fish conf.d directory: %w", err)
		}
	default:
		return fmt.Errorf("unsupported shell: %s", shell)
	}

	if err := os.WriteFile(rcPath, []byte(content), 0644); err != nil {
		return fmt.Errorf("error writing RC file: %w", err)
	}

	return nil
}

// isSourceLinePresent checks if the mark source line is in the config file
func isSourceLinePresent(configPath string) bool {
	file, err := os.Open(configPath)
	if err != nil {
		return false
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		if strings.Contains(line, sourceLineMarker) {
			return true
		}
	}
	return false
}

// ensureSourceLine adds the source line to shell config if not present
func ensureSourceLine(shell string) error {
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return fmt.Errorf("error getting home directory: %w", err)
	}

	var configPath string
	var sourceLine string

	switch shell {
	case "bash":
		configPath = filepath.Join(homeDir, ".bashrc")
		sourceLine = fmt.Sprintf("\n%s\n[ -f ~/%s ] && source ~/%s\n", sourceLineMarker, bashRCFile, bashRCFile)
	case "zsh":
		configPath = filepath.Join(homeDir, ".zshrc")
		sourceLine = fmt.Sprintf("\n%s\n[ -f ~/%s ] && source ~/%s\n", sourceLineMarker, zshRCFile, zshRCFile)
	case "fish":
		// Fish auto-sources files in conf.d, no source line needed
		return nil
	default:
		return fmt.Errorf("unsupported shell: %s", shell)
	}

	// Check if source line already exists
	if isSourceLinePresent(configPath) {
		return nil
	}

	// Append source line
	file, err := os.OpenFile(configPath, os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0644)
	if err != nil {
		return fmt.Errorf("error opening shell config: %w", err)
	}
	defer file.Close()

	if _, err := file.WriteString(sourceLine); err != nil {
		return fmt.Errorf("error writing source line: %w", err)
	}

	return nil
}

// getEnabledFeatures reads the RC file header to detect current features
func getEnabledFeatures(shell string) (aliases, completions bool) {
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return false, false
	}

	var rcPath string
	switch shell {
	case "bash":
		rcPath = filepath.Join(homeDir, bashRCFile)
	case "zsh":
		rcPath = filepath.Join(homeDir, zshRCFile)
	case "fish":
		rcPath = filepath.Join(homeDir, fishRCFile)
	default:
		return false, false
	}

	file, err := os.Open(rcPath)
	if err != nil {
		return false, false
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		if strings.HasPrefix(line, "# Features:") {
			features := strings.TrimPrefix(line, "# Features:")
			aliases = strings.Contains(features, "aliases")
			completions = strings.Contains(features, "completions")
			return
		}
	}
	return false, false
}

// getRCFilePath returns the path to the RC file for the given shell
func getRCFilePath(shell string) string {
	homeDir, _ := os.UserHomeDir()
	switch shell {
	case "bash":
		return filepath.Join(homeDir, bashRCFile)
	case "zsh":
		return filepath.Join(homeDir, zshRCFile)
	case "fish":
		return filepath.Join(homeDir, fishRCFile)
	default:
		return ""
	}
}

// SetupCompletion handles the interactive completion setup prompt
func SetupCompletion(reader *bufio.Reader) {
	// Check if completion is already set up
	if IsCompletionAlreadySetup() {
		return
	}

	fmt.Println()
	fmt.Print("Would you like to set up command line completion for mark? (y/N): ")
	response, _ := reader.ReadString('\n')
	response = strings.ToLower(strings.TrimSpace(response))

	if response != "y" && response != "yes" {
		fmt.Println("Skipping completion setup. You can run 'mark --config' later to set it up.")
		return
	}

	shell := detectShell()
	if shell == "" {
		fmt.Println("Could not detect shell type. Skipping completion setup.")
		return
	}

	switch shell {
	case "bash":
		SetupBashCompletion()
	case "zsh":
		SetupZshCompletion()
	case "fish":
		SetupFishCompletion()
	default:
		fmt.Printf("Shell '%s' not supported for completion. Supported shells: bash, zsh, fish\n", shell)
	}
}

// IsCompletionAlreadySetup checks if command line completion is already configured
func IsCompletionAlreadySetup() bool {
	shell := detectShell()
	if shell == "" {
		return false
	}

	// Check if completions are enabled in the new RC file
	_, completions := getEnabledFeatures(shell)
	if completions {
		return true
	}

	// Also check legacy locations for backwards compatibility
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return false
	}

	switch shell {
	case "bash":
		// Check legacy ~/.mark.bash
		bashCompletionFile := filepath.Join(homeDir, ".mark.bash")
		if _, err := os.Stat(bashCompletionFile); err == nil {
			bashFiles := []string{".bashrc", ".bash_profile", ".profile"}
			for _, file := range bashFiles {
				if CheckFileForCompletionSource(filepath.Join(homeDir, file)) {
					return true
				}
			}
		}
	case "zsh":
		// Check legacy ~/.mark.zsh
		zshCompletionFile := filepath.Join(homeDir, ".mark.zsh")
		if _, err := os.Stat(zshCompletionFile); err == nil {
			if CheckFileForCompletionSource(filepath.Join(homeDir, ".zshrc")) {
				return true
			}
		}
	case "fish":
		// Check legacy fish completion location
		fishCompletionFile := filepath.Join(homeDir, ".config", "fish", "completions", "mark.fish")
		_, err := os.Stat(fishCompletionFile)
		return err == nil
	}
	return false
}

// CheckFileForCompletionSource checks if a file sources mark completion
func CheckFileForCompletionSource(filePath string) bool {
	file, err := os.Open(filePath)
	if err != nil {
		return false
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		// Check for new unified RC files
		if strings.Contains(line, ".mark_bash_rc") || strings.Contains(line, ".mark_zsh_rc") {
			return true
		}
		// Check for legacy .mark.bash/.mark.zsh files
		if (strings.Contains(line, "~/.mark.bash") || strings.Contains(line, "~/.mark.zsh")) &&
			(strings.Contains(line, "source") || strings.Contains(line, ".")) ||
			(strings.Contains(line, "mark") && (strings.Contains(line, "complete") || strings.Contains(line, "completion"))) {
			return true
		}
	}
	return false
}

// SetupBashCompletion sets up bash command completion
func SetupBashCompletion() {
	homeDir, err := os.UserHomeDir()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error getting home directory: %v\n", err)
		return
	}

	// Check if aliases are already enabled (preserve them)
	aliases, _ := getEnabledFeatures("bash")

	// Write unified RC file with completions enabled
	if err := writeShellRC("bash", aliases, true); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing bash RC file: %v\n", err)
		return
	}

	// Add source line to .bashrc if not present
	if err := ensureSourceLine("bash"); err != nil {
		fmt.Fprintf(os.Stderr, "Error updating .bashrc: %v\n", err)
		return
	}

	rcPath := filepath.Join(homeDir, bashRCFile)
	fmt.Printf("✓ Bash completion setup complete!\n")
	fmt.Printf("  Created configuration at %s\n", rcPath)
	fmt.Printf("  Updated ~/.bashrc to source configuration\n")
	fmt.Printf("  Run 'source ~/.bashrc' or restart your shell to activate completions\n")
}

// SetupZshCompletion sets up zsh command completion
func SetupZshCompletion() {
	homeDir, err := os.UserHomeDir()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error getting home directory: %v\n", err)
		return
	}

	// Check if aliases are already enabled (preserve them)
	aliases, _ := getEnabledFeatures("zsh")

	// Write unified RC file with completions enabled
	if err := writeShellRC("zsh", aliases, true); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing zsh RC file: %v\n", err)
		return
	}

	// Add source line to .zshrc if not present
	if err := ensureSourceLine("zsh"); err != nil {
		fmt.Fprintf(os.Stderr, "Error updating .zshrc: %v\n", err)
		return
	}

	rcPath := filepath.Join(homeDir, zshRCFile)
	fmt.Printf("✓ Zsh completion setup complete!\n")
	fmt.Printf("  Created configuration at %s\n", rcPath)
	fmt.Printf("  Updated ~/.zshrc to source configuration\n")
	fmt.Printf("  Restart your shell or run: source ~/.zshrc\n")
}

// SetupFishCompletion sets up fish command completion
func SetupFishCompletion() {
	homeDir, err := os.UserHomeDir()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error getting home directory: %v\n", err)
		return
	}

	// Check if aliases are already enabled (preserve them)
	aliases, _ := getEnabledFeatures("fish")

	// Write unified RC file with completions enabled
	if err := writeShellRC("fish", aliases, true); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing fish RC file: %v\n", err)
		return
	}

	rcPath := filepath.Join(homeDir, fishRCFile)
	fmt.Printf("✓ Fish completion setup complete!\n")
	fmt.Printf("  Created configuration at %s\n", rcPath)
	fmt.Printf("  Fish auto-sources files in conf.d, restart your shell to activate\n")
}

// RunAutocompleteSetup handles the main autocomplete setup flow
func RunAutocompleteSetup() {
	reader := bufio.NewReader(os.Stdin)

	fmt.Println("mark - Command Line Autocompletion Setup")
	fmt.Println()
	fmt.Println("This will set up tab completion for the mark command, allowing you to:")
	fmt.Println("• Tab-complete bookmark names")
	fmt.Println("• Tab-complete command flags")
	fmt.Println("• Get context-aware completions")
	fmt.Println()
	fmt.Print("Would you like to set up autocompletion? (y/N): ")

	response, _ := reader.ReadString('\n')
	response = strings.ToLower(strings.TrimSpace(response))

	if response != "y" && response != "yes" {
		fmt.Println("Autocompletion setup cancelled.")
		return
	}

	shell := detectShell()
	if shell == "" {
		fmt.Println("Could not detect shell type. Skipping completion setup.")
		fmt.Println("Supported shells: bash, zsh, fish")
		return
	}

	fmt.Printf("Detected shell: %s\n", shell)
	fmt.Println()

	// Clean up any existing completion setup
	fmt.Println("Cleaning up any existing completion setup...")
	CleanupExistingCompletion(shell)

	// Set up completion for the detected shell
	fmt.Printf("Setting up %s completion...\n", shell)
	switch shell {
	case "bash":
		SetupBashCompletion()
	case "zsh":
		SetupZshCompletion()
	case "fish":
		SetupFishCompletion()
	default:
		fmt.Printf("Shell '%s' not supported for completion. Supported shells: bash, zsh, fish\n", shell)
		return
	}

	fmt.Println()
	fmt.Println("✓ Autocompletion setup complete!")
	fmt.Println("  To activate, run one of:")

	switch shell {
	case "bash":
		fmt.Printf("    source ~/.bashrc\n")
		fmt.Printf("    source ~/%s\n", bashRCFile)
	case "zsh":
		fmt.Printf("    source ~/.zshrc\n")
		fmt.Printf("    source ~/%s\n", zshRCFile)
	case "fish":
		fmt.Println("    (restart your shell)")
	}
	fmt.Println("  Or simply restart your shell")
}

// CleanupExistingCompletion removes existing completion setup for the specified shell
func CleanupExistingCompletion(shell string) {
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return
	}

	switch shell {
	case "bash":
		// Remove legacy .mark.bash file
		os.Remove(filepath.Join(homeDir, ".mark.bash"))
		// Remove new unified RC file
		os.Remove(filepath.Join(homeDir, bashRCFile))

		// Clean up shell config files (removes old mark entries, preserves new source line)
		cleanupShellConfigLegacy(filepath.Join(homeDir, ".bashrc"))
		cleanupShellConfigLegacy(filepath.Join(homeDir, ".bash_profile"))
		cleanupShellConfigLegacy(filepath.Join(homeDir, ".profile"))

	case "zsh":
		// Remove legacy .mark.zsh file
		os.Remove(filepath.Join(homeDir, ".mark.zsh"))
		// Remove new unified RC file
		os.Remove(filepath.Join(homeDir, zshRCFile))

		// Clean up .zshrc
		cleanupShellConfigLegacy(filepath.Join(homeDir, ".zshrc"))

	case "fish":
		// Remove legacy fish completion file
		os.Remove(filepath.Join(homeDir, ".config", "fish", "completions", "mark.fish"))
		// Remove new unified RC file
		os.Remove(filepath.Join(homeDir, fishRCFile))
		// Clean up legacy aliases from config.fish
		cleanupFishConfigLegacy(filepath.Join(homeDir, ".config", "fish", "config.fish"))
	}
}

// cleanupShellConfigLegacy removes legacy mark entries from shell config files
// but preserves the new unified source line
func cleanupShellConfigLegacy(configFile string) {
	file, err := os.Open(configFile)
	if err != nil {
		return
	}
	defer file.Close()

	var lines []string
	scanner := bufio.NewScanner(file)
	skipUntilBlank := false
	inMarkAliasBlock := false

	for scanner.Scan() {
		line := scanner.Text()

		// Skip legacy "# mark command completion" blocks
		if strings.Contains(line, "# mark command completion") {
			skipUntilBlank = true
			continue
		}

		// Skip legacy "# mark command aliases" blocks
		if strings.Contains(line, "# mark command aliases") {
			inMarkAliasBlock = true
			continue
		}

		// Skip lines in legacy completion blocks
		if skipUntilBlank {
			if strings.Contains(line, ".mark.bash") ||
				strings.Contains(line, ".mark.zsh") ||
				strings.Contains(line, "completions/bash/mark") ||
				(strings.Contains(line, "autoload") && strings.Contains(line, "compinit")) ||
				(strings.Contains(line, "mark") && strings.Contains(line, "source")) {
				continue
			}
			if strings.TrimSpace(line) == "" {
				skipUntilBlank = false
				continue
			}
			skipUntilBlank = false
		}

		// Skip lines in legacy alias blocks
		if inMarkAliasBlock {
			if strings.Contains(line, "alias marks=") ||
				strings.Contains(line, "alias unmark=") ||
				strings.Contains(line, "function jump") ||
				strings.Contains(line, "local target=$(") ||
				strings.Contains(line, "cd \"$target\"") ||
				strings.TrimSpace(line) == "}" {
				continue
			}
			if strings.TrimSpace(line) == "" {
				inMarkAliasBlock = false
				continue
			}
			// Check for jump function body lines
			trimmed := strings.TrimSpace(line)
			if trimmed == "if [ $? -eq 0 ] && [ -n \"$target\" ]; then" ||
				trimmed == "fi" {
				continue
			}
			inMarkAliasBlock = false
		}

		lines = append(lines, line)
	}

	// Write the cleaned file back
	outFile, err := os.Create(configFile)
	if err != nil {
		return
	}
	defer outFile.Close()

	for _, line := range lines {
		fmt.Fprintln(outFile, line)
	}
}

// cleanupFishConfigLegacy removes legacy mark aliases from fish config.fish
func cleanupFishConfigLegacy(configFile string) {
	file, err := os.Open(configFile)
	if err != nil {
		return
	}
	defer file.Close()

	var lines []string
	scanner := bufio.NewScanner(file)
	inMarkBlock := false
	inJumpFunction := false

	for scanner.Scan() {
		line := scanner.Text()

		// Skip "# mark command aliases" comment
		if strings.Contains(line, "# mark command aliases") {
			inMarkBlock = true
			continue
		}

		if inMarkBlock {
			// Skip alias lines
			if strings.Contains(line, "alias marks ") ||
				strings.Contains(line, "alias unmark ") {
				continue
			}
			// Skip jump function
			if strings.HasPrefix(strings.TrimSpace(line), "function jump") {
				inJumpFunction = true
				continue
			}
			if inJumpFunction {
				if strings.TrimSpace(line) == "end" {
					inJumpFunction = false
					continue
				}
				continue
			}
			// End of mark block on blank line
			if strings.TrimSpace(line) == "" {
				inMarkBlock = false
				continue
			}
			inMarkBlock = false
		}

		lines = append(lines, line)
	}

	// Write the cleaned file back
	outFile, err := os.Create(configFile)
	if err != nil {
		return
	}
	defer outFile.Close()

	for _, line := range lines {
		fmt.Fprintln(outFile, line)
	}
}

// cleanupShellConfigSourceLine removes the new mark source line from shell config
func cleanupShellConfigSourceLine(configFile string) {
	file, err := os.Open(configFile)
	if err != nil {
		return
	}
	defer file.Close()

	var lines []string
	scanner := bufio.NewScanner(file)
	skipNext := false

	for scanner.Scan() {
		line := scanner.Text()

		// Skip "# mark shell integration" and the following source line
		if strings.Contains(line, sourceLineMarker) {
			skipNext = true
			continue
		}

		if skipNext && (strings.Contains(line, ".mark_bash_rc") ||
			strings.Contains(line, ".mark_zsh_rc")) {
			skipNext = false
			continue
		}

		skipNext = false
		lines = append(lines, line)
	}

	// Write the cleaned file back
	outFile, err := os.Create(configFile)
	if err != nil {
		return
	}
	defer outFile.Close()

	for _, line := range lines {
		fmt.Fprintln(outFile, line)
	}
}
